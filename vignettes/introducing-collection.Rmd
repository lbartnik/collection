---
title: "Storing Objects in a Collection"
author: "Åukasz A. Bartnik"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Storing Objects in a Collection}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include=FALSE}
library(collection)
library(knitr)

knitr::opts_chunk$set(collapse = TRUE, comment = "#>", eval=FALSE)
```


## General Remarks

Collections can be used in both interactive and programmatic mode. In the
interactive mode a number of heuristic and (hopefully) smart guesses are
used to ease the use of the package. In the programmatic mode none such
guesses are present to make the API simple and predictable.

Following the convention introduced in the `lazyeval` package, functions
indenteded for interactive use have names that end with a letter while
their programmatic counterparts' names have an underscore appended to
the original name. For example:

```{r}
restore() # is intended for interactive use
restore_() # is intended for programmatic use
```


## Basics

First we create a collection and store an object in it.

```{r}
x <- collection('objects')
store(x, iris)
```


Let's a summary of `x` and then list objects stored there:

```{r}
print(x)
show(x)
```


Finally, let's read that object back:

```{r}
restore(x, name == 'iris')
restore(x, 'id')
```


## Multiple Objects

What are the use cases when working with multiple objects? In order to
illustrate them we will use a handy collection generator that comes
with the `collection` package.

We create `n = 12` time series objects, each `len = 96` observations
long. We also provide the random seed.

```{r}
ts_col <- sample_time_series(n = 12, len = 96, seed = 1)
```



Now we can list the collection:

TODO should show the `no` tag

```{r}
print(ts_col)
```



Let's now apply a function on each object in this collection:

```{r}
do(ts_col, function (obj) {
  
})
```

What if we only want to apply this function on a subset of objects?

```{r}
filter(ts_col, no < 7) %>%
  do(function (obj) {
    
  })
```


### Exploring with a single object

Let's pick a single time series data set and see what kind of model we
can fit.

```{r}
ts <- restore(ts_col, no == 1)
summary(ts)
lm(x ~ a + b + c, data = ts)
```


### Fit model to all objects in a collection

```{r}
ts_col %>%
  do(function (obj) {
    lm(x ~ a + b + c, data = obj)
  })
```
